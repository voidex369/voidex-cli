import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { Box, Text, useInput, useApp, Static } from 'ink';
import TextInput from 'ink-text-input';
// [FIX] Hapus import Spinner (sudah kita matikan sebelumnya)
// import Spinner from 'ink-spinner'; 
import Gradient from 'ink-gradient';
import { useChat, Message } from '../hooks/useChat.js';
import { getAvailableModels, saveModel, saveApiKey, getApiKey, getModelDisplayName } from '../../lib/config.js';

// --- Sub-components (Memoized for Extreme Stability) ---

const HelpMenu = React.memo(() => (
    <Box flexDirection="column" borderStyle="double" borderColor="cyan" padding={1} marginBottom={1}>
        <Text bold color="cyan">Basics:</Text>
        <Text> Add context: Use @ to specify files for context (Coming Soon)</Text>
        <Text> Shell mode: Use natural language or execute bash directly via tools.</Text>

        <Box marginTop={1} flexDirection="column">
            <Text bold color="magenta">Commands:</Text>
            <Text>  /about          - Show version info</Text>
            <Text>  /clear          - Clear screen and conversation history</Text>
            <Text>  /help           - Show this help menu</Text>
            <Text>  /model          - Configure LLM model</Text>
            <Text>  /stats          - Check system stats (RAM, CPU, etc)</Text>
            <Text>  /tools          - List available Sovereign tools</Text>
            <Text>  /auth           - Update API Key (Get at: https://openrouter.ai/keys)</Text>
            <Text bold color="green">  /chat           - Manage conversation history</Text>
            <Text>    save {'<id>'}   - Save current session as checkpoint</Text>
            <Text>    resume {'<id>'} - Resume session from checkpoint</Text>
            <Text>    list          - List all saved sessions</Text>
            <Text>    delete {'<id>'} - Delete a session checkpoint</Text>
            <Text>    share {'<file>'} - Share chat to file (.json or .txt)</Text>
        </Box>

        <Box marginTop={1} flexDirection="column">
            <Text bold color="yellow">Keyboard Shortcuts:</Text>
            <Text> Ctrl+C      - Quit (or Cancel Thinking)</Text>
            <Text> Tab         - Autocomplete suggestion</Text>
            <Text> Up/Down     - Cycle history or suggestions</Text>
            <Text> Enter       - Send message</Text>
        </Box>

        <Box marginTop={1} flexDirection="column" borderStyle="round" borderColor="white">
            <Text bold color="white">By VoidEx</Text>
            <Text> Telegram: https://t.me/voidex369</Text>
            <Text> GitHub:   https://github.com/voidex369</Text>
        </Box>
    </Box>
));

const ToolsList = React.memo(({ content }: { content: string }) => {
    const tools = content.replace('Available Tools:\n', '').split('\n');
    return (
        <Box flexDirection="column" borderStyle="round" borderColor="green" padding={1} marginBottom={1}>
            <Text bold color="green">Available Sovereign Tools:</Text>
            {tools.map((t, i) => (
                <Text key={i} color="white">  {t}</Text>
            ))}
        </Box>
    );
});

const WelcomeBox = React.memo(() => (
    <Box flexDirection="column" marginBottom={1}>
        <Gradient name="pastel">
            <Text bold>VoidEx CLI | By VoidEx üè¥‚ò†Ô∏è</Text>
        </Gradient>
        <Box flexDirection="column" borderStyle="round" borderColor="cyan" padding={1} marginTop={1}>
            <Text>By VoidEx | Telegram: https://t.me/voidex369</Text>
            <Box marginTop={1}>
                <Text>Type <Text color="yellow">/help</Text> to see available commands.</Text>
            </Box>
        </Box>
    </Box>
));

const TruncatedResultBox = React.memo(({ content, isSuccess }: { content: string, isSuccess: boolean }) => {
    if (!content) return <Text dimColor>(no output)</Text>;

    const RENDER_LIMIT = 10000;
    if (content.length > RENDER_LIMIT) {
        return (
            <Box flexDirection="column">
                <Text dimColor>{content.slice(0, 1000)} ...</Text>
                <Box marginY={1} paddingX={1} borderStyle="single" borderColor="red">
                    <Text bold color="red">‚ö† LARGE OUTPUT ({Math.round(content.length / 1024)} KB)</Text>
                    <Text color="yellow">Memory protected. Full output truncated in terminal.</Text>
                </Box>
            </Box>
        );
    }

    const lines = content.split('\n');
    const MAX_LINES = 15;
    if (lines.length <= MAX_LINES) return <Text dimColor>{content}</Text>;

    const first7 = lines.slice(0, 7);
    const last7 = lines.slice(-7);
    const hidden = lines.length - 14;

    return (
        <Box flexDirection="column">
            {first7.map((l, i) => <Text key={`f-${i}`} dimColor>{l}</Text>)}
            <Box marginY={1} paddingX={1} borderStyle="single" borderColor="gray">
                <Text italic color="yellow">... [ {hidden} lines hidden for stability ] ...</Text>
            </Box>
            {last7.map((l, i) => <Text key={`l-${i}`} dimColor>{l}</Text>)}
        </Box>
    );
});


const MessageItem = React.memo(({ msg }: { msg: Message }) => {
    if (msg.role === 'system') {
        if (msg.name === 'welcome_msg') return <WelcomeBox />;
        if (msg.name === 'help_menu') return <HelpMenu />;
        if (msg.name === 'tools_list') return <ToolsList content={msg.content || ''} />;
        return <Box paddingX={1} marginBottom={1}><Text color="gray" italic>‚ú¶ {msg.content}</Text></Box>;
    }

    if (msg.role === 'tool') {
        const isSuccess = !msg.content?.toLowerCase().includes('error') && !msg.content?.toLowerCase().includes('failed');
        return (
            <Box flexDirection="column" marginLeft={2} marginBottom={1} borderStyle="round" borderColor={isSuccess ? 'green' : 'red'} paddingX={1}>
                <Text bold color={isSuccess ? 'green' : 'red'}>{isSuccess ? '‚úì' : '‚úñ'} Tool Result:</Text>
                <TruncatedResultBox content={msg.content || ''} isSuccess={isSuccess} />
            </Box>
        );
    }

    if (msg.role === 'assistant') {
        const hasTools = msg.tool_calls && msg.tool_calls.length > 0;
        return (
            <Box flexDirection="column" marginBottom={1}>
                {/* Unified Header */}
                <Text bold color="magenta">Agent:</Text>

                {/* Content Area */}
                {msg.content && (
                    <Box paddingLeft={2} marginBottom={hasTools ? 1 : 0}>
                        <Text>{msg.content}</Text>
                    </Box>
                )}

                {/* Tool Calls Area */}
                {hasTools && msg.tool_calls!.map((tc: any, idx: number) => {
                    let formattedArgs = tc.function.arguments;
                    if (formattedArgs.length > 50) {
                        try {
                            const parsed = JSON.parse(tc.function.arguments);
                            if (parsed.content && parsed.content.length > 100) {
                                parsed.content = parsed.content.substring(0, 100) + '...';
                            }
                            formattedArgs = JSON.stringify(parsed, null, 2);
                        } catch (e) {
                            if (formattedArgs.length > 150) formattedArgs = formattedArgs.slice(0, 150) + '...';
                        }
                    }

                    return (
                        <Box key={idx} flexDirection="column" borderStyle="round" borderColor="cyan" paddingX={1} marginTop={idx === 0 ? 0 : 1}>
                            <Text bold color="cyan">‚öô Tool Call: {tc.function.name}</Text>
                            <Box paddingLeft={1}><Text dimColor italic>{formattedArgs}</Text></Box>
                        </Box>
                    );
                })}
            </Box>
        );
    }

    return (
        <Box flexDirection="column" marginBottom={1}>
            <Text bold color="blue">You:</Text>
            <Box paddingLeft={2}><Text>{msg.content}</Text></Box>
        </Box>
    );
});

const ModelPicker = React.memo(({ onSelect, onCancel, models }: any) => {
    const [filter, setFilter] = useState('');
    const [selectedIndex, setSelectedIndex] = useState(0);

    const filtered = useMemo(() => models.filter((m: string) => m.toLowerCase().includes(filter.toLowerCase())), [filter, models]);

    const visibleCount = 10;
    const totalCount = filtered.length;
    const startIndex = Math.floor(selectedIndex / visibleCount) * visibleCount;
    const visible = useMemo(() => filtered.slice(startIndex, startIndex + visibleCount), [filtered, startIndex]);

    useInput((input, key) => {
        if (totalCount === 0) {
            if (key.escape || (key.ctrl && input === 'c')) onCancel();
            return;
        }

        if (key.upArrow) setSelectedIndex(p => (p > 0 ? p - 1 : totalCount - 1));
        else if (key.downArrow) setSelectedIndex(p => (p < totalCount - 1 ? p + 1 : 0));
        else if (key.pageUp) setSelectedIndex(p => Math.max(0, p - 10));
        else if (key.pageDown) setSelectedIndex(p => Math.min(totalCount - 1, p + 10));
        else if (key.return) { if (filtered[selectedIndex]) onSelect(filtered[selectedIndex]); }
        else if (key.escape || (key.ctrl && input === 'c')) onCancel();
    });

    return (
        <Box flexDirection="column" borderStyle="double" borderColor="magenta" padding={1} width={80} flexShrink={0}>
            <Text bold color="magenta">Select Model (Esc to cancel):</Text>

            <Box borderStyle="single" borderColor="gray" paddingX={1} marginBottom={1} flexShrink={0}>
                <TextInput value={filter} onChange={(v) => { setFilter(v); setSelectedIndex(0); }} placeholder="Search models..." />
            </Box>

            <Box flexDirection="column" flexShrink={0}>
                {visible.map((m: string, i: number) => {
                    const absIdx = startIndex + i;
                    const isSel = absIdx === selectedIndex;
                    const displayName = getModelDisplayName(m);
                    const safeName = displayName.length > 70 ? displayName.slice(0, 67) + '...' : displayName;

                    return (
                        <Text key={`${m}-${absIdx}`} color={isSel ? 'cyan' : 'white'} bold={isSel} wrap="truncate">
                            {isSel ? '‚û§ ' : '  '}{safeName}
                        </Text>
                    );
                })}
            </Box>

            <Box marginTop={1} paddingX={1} borderStyle="single" borderColor="gray" flexShrink={0}>
                <Text dimColor>
                    Found: {totalCount} | Page: {Math.floor(startIndex / visibleCount) + 1} of {Math.max(1, Math.ceil(totalCount / visibleCount))}
                </Text>
            </Box>
        </Box>
    );
});

const AuthDialog = React.memo(({ onSave, onCancel, currentKey }: any) => {
    const [key, setKey] = useState('');

    useInput((input, keyData) => {
        if (keyData.escape) onCancel();
        if (keyData.ctrl && input.toLowerCase() === 'c') onCancel();
    });

    const maskedKey = currentKey ? currentKey.substring(0, 8) + '...' + currentKey.substring(currentKey.length - 4) : 'None';

    return (
        <Box flexDirection="column" borderStyle="double" borderColor="yellow" padding={1} width={80}>
            <Text bold color="yellow">Update API Key (Esc to cancel):</Text>
            <Box marginTop={1} paddingX={1} borderStyle="single" borderColor="gray">
                <Text dimColor>Current: <Text color="white" bold>{maskedKey}</Text></Text>
            </Box>
            <Box borderStyle="single" borderColor="white" paddingX={1} marginTop={1}>
                <TextInput value={key} onChange={setKey} onSubmit={onSave} placeholder="Paste new API Key here..." focus={true} />
            </Box>
            <Box marginTop={1}><Text dimColor italic>Get your keys at: <Text color="cyan" bold underline>https://openrouter.ai/keys</Text></Text></Box>
            <Box marginTop={1}><Text dimColor italic>New key will replace the old one. Leave empty to keep current.</Text></Box>
        </Box>
    );
});

const StatusArea = React.memo(({ agentStatus, liveToolOutput, pendingApproval, approvalOptions, approvalIndex }: any) => {
    if (!agentStatus && !pendingApproval) return null;
    const cappedOutput = useMemo(() => {
        if (!liveToolOutput) return '';
        const lines = liveToolOutput.split('\n').map((l: string) => l.length > 80 ? l.slice(0, 77) + '...' : l);
        return lines.length > 10 ? '...\n' + lines.slice(-10).join('\n') : lines.join('\n');
    }, [liveToolOutput]);

    return (
        <Box flexDirection="column" flexShrink={0}>
            {agentStatus && (
                <Box borderStyle="single" borderColor="yellow" paddingX={1} marginBottom={1} flexDirection="column">
                    <Box><Text color="yellow">‚è≥</Text><Text> {agentStatus}</Text></Box>
                    {cappedOutput && <Box marginTop={1} paddingX={1} borderStyle="single" borderColor="gray"><Text color="gray">{cappedOutput}</Text></Box>}
                </Box>
            )}
            {pendingApproval && (
                <Box flexDirection="column" borderStyle="round" borderColor="yellow" paddingX={1} marginBottom={1}>
                    <Text bold color="yellow">‚ö† Safety Check: {pendingApproval.name}</Text>
                    <Box flexDirection="column" marginTop={1}>
                        {approvalOptions.map((opt: any, i: number) => (
                            <Text key={opt.value} color={i === approvalIndex ? 'cyan' : 'white'} bold={i === approvalIndex}>
                                {i === approvalIndex ? '‚óè' : ' '} {opt.label}
                            </Text>
                        ))}
                    </Box>
                </Box>
            )}
        </Box>
    );
});

const InputArea = React.memo(({ input, setInput, handleSend, suggestions, selectedIndex }: any) => (
    <Box flexDirection="column" flexShrink={0}>
        {suggestions.length > 0 && (
            <Box flexDirection="column" borderStyle="round" borderColor="gray" paddingX={1} marginBottom={1}>
                {suggestions.map((s: any, i: number) => (
                    <Box key={s.cmd} flexDirection="row">
                        <Text color={i === selectedIndex ? 'cyan' : 'white'} bold={i === selectedIndex}>
                            {i === selectedIndex ? '> ' : '  '}{s.cmd}
                        </Text>
                        <Text dimColor> - {s.desc}</Text>
                    </Box>
                ))}
            </Box>
        )}
        <Box borderStyle="single" borderColor="green" paddingX={1}>
            <Box marginRight={1}><Text bold color="green">‚ùØ</Text></Box>
            <Box flexGrow={1}><TextInput value={input} onChange={setInput} onSubmit={handleSend} placeholder="Type or / for commands..." /></Box>
        </Box>
    </Box>
));

// --- Isolated Chat View ---
const ChatView = React.memo(({ onDialog, chatState }: any) => {
    const {
        messages, isLoading, error, sendMessage, agentStatus, stopLoading,
        hasMemory, pendingApproval, resolveApproval, liveToolOutput,
        history, setHistory, forgetMessages
    } = chatState;
    const { exit } = useApp();
    const [input, setInput] = useState('');
    const [suggestions, setSuggestions] = useState<any[]>([]);
    const [selIdx, setSelIdx] = useState(0);
    const [apprIdx, setApprIdx] = useState(0);
    const apprOpts = useMemo(() => [{ label: 'Allow once', value: 'allow' }, { label: 'Always', value: 'always' }, { label: 'Deny', value: 'deny' }], []);

    const [histIdx, setHistIdx] = useState(-1);
    const lastCtrlCTime = useRef(0);
    const [showExitNotice, setShowExitNotice] = useState(false);

    const isTTY = process.stdout.isTTY;
    const prevStaticRef = useRef<Message[]>([]);

    // [FIX 3] DOUBLE PRINTING SOLVED:
    // Kita memaksa pesan terakhir (Assistant) tetap di status "Active" (bukan Static)
    // meskipun streaming sudah selesai. Ini mencegah transisi re-render yang menyebabkan teks tercetak ganda.
    // Pesan ini baru akan masuk ke <Static> (history) ketika user mengirim pesan BERIKUTNYA.
    const isLastMessageAssistant = messages.length > 0 && messages[messages.length - 1].role === 'assistant';
    const shouldKeepActive = isTTY && (isLoading || isLastMessageAssistant);

    const { staticMessages, activeMessage } = useMemo(() => {
        const RENDER_WINDOW = 150;
        const windowed = messages.length > RENDER_WINDOW ? messages.slice(-RENDER_WINDOW) : messages;
        
        let staticMsgs: Message[];
        let activeMsg: Message | null = null;

        if (shouldKeepActive) {
            // Keep the last message in Active slot
            staticMsgs = windowed.slice(0, -1);
            activeMsg = windowed[windowed.length - 1];
        } else {
            // Flush all to static
            staticMsgs = windowed;
            activeMsg = null;
        }

        // Deep stability check to prevent Static refresh
        if (
            staticMsgs.length === prevStaticRef.current.length &&
            staticMsgs.every((m, i) => m === prevStaticRef.current[i])
        ) {
            staticMsgs = prevStaticRef.current;
        } else {
            prevStaticRef.current = staticMsgs;
        }

        return { staticMessages: staticMsgs, activeMessage: activeMsg };
    }, [messages, shouldKeepActive, isTTY]);

    useEffect(() => {
        const allCmds = [
            { cmd: '/help', desc: 'Show help menu' },
            { cmd: '/tools', desc: 'List available tools...' },
            { cmd: '/tools desc', desc: 'List tools with descriptions', parent: '/tools' },
            { cmd: '/model', desc: 'Select AI model' },
            { cmd: '/clear', desc: 'Clear conversation' },
            { cmd: '/about', desc: 'Version info' },
            { cmd: '/stats', desc: 'System statistics...' },
            { cmd: '/stats session', desc: 'Session metrics', parent: '/stats' },
            { cmd: '/stats model', desc: 'Model metrics', parent: '/stats' },
            { cmd: '/auth', desc: 'Enter API Key' },
            { cmd: '/chat', desc: 'Session management...' },
            { cmd: '/chat save', desc: 'Save current session', parent: '/chat' },
            { cmd: '/chat resume', desc: 'Resume a session', parent: '/chat' },
            { cmd: '/chat list', desc: 'List saved sessions', parent: '/chat' },
            { cmd: '/chat delete', desc: 'Delete a session', parent: '/chat' },
            { cmd: '/chat share', desc: 'Share chat to file', parent: '/chat' },
            { cmd: '/forget', desc: 'Forget last N interactions' }
        ];

        if (input.startsWith('/')) {
            const isChatMode = input.startsWith('/chat');
            const isStatsMode = input.startsWith('/stats');
            const isToolsMode = input.startsWith('/tools');

            const filtered = allCmds.filter(c => {
                if (isChatMode) return c.parent === '/chat' && c.cmd.startsWith(input) && c.cmd !== input;
                if (isStatsMode) return c.parent === '/stats' && c.cmd.startsWith(input) && c.cmd !== input;
                if (isToolsMode) return c.parent === '/tools' && c.cmd.startsWith(input) && c.cmd !== input;
                return !c.parent && c.cmd.startsWith(input) && c.cmd !== input;
            });
            setSuggestions(filtered);
        } else {
            setSuggestions([]);
        }
        setSelIdx(0);
    }, [input]);

    useInput((inputChars, key) => {
        if (pendingApproval) {
            if (key.upArrow) setApprIdx(p => (p > 0 ? p - 1 : apprOpts.length - 1));
            else if (key.downArrow) setApprIdx(p => (p < apprOpts.length - 1 ? p + 1 : 0));
            else if (key.return) resolveApproval(apprOpts[apprIdx].value as any);
            return;
        }

        if (key.ctrl && inputChars === 'c') {
            if (isLoading) {
                stopLoading();
            } else {
                const now = Date.now();
                if (now - lastCtrlCTime.current < 2000) {
                    exit();
                } else {
                    lastCtrlCTime.current = now;
                    setShowExitNotice(true);
                    setTimeout(() => setShowExitNotice(false), 2000);
                }
            }
            return;
        }

        if (suggestions.length > 0) {
            if (key.tab && suggestions[selIdx]) {
                setInput(suggestions[selIdx].cmd + (suggestions[selIdx].cmd.endsWith(' ') ? '' : ' '));
                setSuggestions([]);
            }
            else if (key.upArrow) setSelIdx(p => (p > 0 ? p - 1 : suggestions.length - 1));
            else if (key.downArrow) setSelIdx(p => (p < suggestions.length - 1 ? p + 1 : 0));
            return;
        }

        if (key.upArrow) {
            setHistIdx(prev => {
                const newIdx = Math.min(prev + 1, history.length - 1);
                if (newIdx !== prev && newIdx >= 0) setInput(history[history.length - 1 - newIdx]);
                return newIdx;
            });
        }
        else if (key.downArrow) {
            setHistIdx(prev => {
                const newIdx = Math.max(prev - 1, -1);
                if (newIdx === -1) setInput('');
                else if (newIdx !== prev) setInput(history[history.length - 1 - newIdx]);
                return newIdx;
            });
        }
        else if (key.pageUp) {
            setHistIdx(prev => {
                const newIdx = Math.min(prev + 5, history.length - 1);
                if (newIdx !== prev && newIdx >= 0) setInput(history[history.length - 1 - newIdx]);
                return newIdx;
            });
        }
        else if (key.pageDown) {
            setHistIdx(prev => {
                const newIdx = Math.max(prev - 5, -1);
                if (newIdx === -1) setInput('');
                else if (newIdx !== prev) setInput(history[history.length - 1 - newIdx]);
                return newIdx;
            });
        }
    });

    const handleSend = useCallback((v: string) => {
        const trimmed = v.trim().toLowerCase();
        if (trimmed === '/model' || trimmed === '/auth') {
            onDialog(trimmed.slice(1));
            setInput('');
            return;
        }
        if (trimmed.startsWith('/forget')) {
            const count = parseInt(trimmed.split(' ')[1]) || 1;
            forgetMessages(count);
            setInput('');
            return;
        }
        if (v.trim()) {
            sendMessage(v);
            setHistory((prev: string[]) => {
                const last = prev[prev.length - 1];
                if (last === v) return prev;
                return [...prev, v];
            });
            setHistIdx(-1);
        }
        setInput('');
    }, [sendMessage, onDialog]);

    return (
        <Box flexDirection="column" width="100%">
            {/* Static History */}
            <Static items={staticMessages}>
                {(msg: any) => (
                    <Box key={msg.id} width="100%">
                        <MessageItem msg={msg} />
                    </Box>
                )}
            </Static>

            {/* Active / Streaming Message */}
            {activeMessage && (
                <Box width="100%" paddingX={1} marginBottom={1}>
                    <MessageItem msg={activeMessage} />
                </Box>
            )}

            {/* Footer Area */}
            <Box flexDirection="column" marginTop={1} borderStyle="single" borderColor="gray" paddingTop={1}>
                {showExitNotice && <Box marginLeft={1} marginBottom={1}><Text color="yellow" bold>‚ö† Press Ctrl+C again to exit</Text></Box>}
                {error && <Text color="red" bold>‚úñ Error: {error}</Text>}
                {hasMemory && <Box marginLeft={1} marginBottom={1}><Text dimColor italic>Sovereign memory active</Text></Box>}
                {isTTY && <StatusArea agentStatus={agentStatus} liveToolOutput={liveToolOutput} pendingApproval={pendingApproval} approvalOptions={apprOpts} approvalIndex={apprIdx} />}
                <InputArea input={input} setInput={setInput} handleSend={handleSend} suggestions={suggestions} selectedIndex={selIdx} />
            </Box>
        </Box>
    );
});

export default function Chat() {
    const chatState = useChat();
    const { sendMessage } = chatState;
    const [dialog, setDialog] = useState<null | 'model' | 'auth'>(null);
    const models = useMemo(() => getAvailableModels(), []);

    const handleModelSelect = useCallback((m: string) => {
        saveModel(m);
        setDialog(null);
        sendMessage(`SYSTEM_MODEL_CHANGED:${m}`);
    }, [sendMessage]);

    const handleAuthSave = useCallback((k: string) => {
        if (k.trim()) {
            saveApiKey(k.trim());
            sendMessage(`SYSTEM_AUTH_CHANGED:OK`);
        }
        setDialog(null);
    }, [sendMessage]);

    const closeDialog = useCallback(() => setDialog(null), []);

    if (dialog === 'model') return <Box padding={2}><ModelPicker models={models} onSelect={handleModelSelect} onCancel={closeDialog} /></Box>;
    if (dialog === 'auth') return <Box padding={2}><AuthDialog currentKey={getApiKey() || ''} onSave={handleAuthSave} onCancel={closeDialog} /></Box>;

    return <ChatView onDialog={setDialog} chatState={chatState} />;
}
